//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IClient {

    /**
     * @param searchTerm (optional) 
     * @param tags (optional) 
     * @param isPhoto (optional) 
     * @param folderId (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @return OK
     */
    filesGET(searchTerm?: string | undefined, tags?: string[] | undefined, isPhoto?: boolean | undefined, folderId?: string | undefined, skip?: number | undefined, take?: number | undefined): Promise<SearchFilesResult>;

    /**
     * @return OK
     */
    filesGET2(id: string): Promise<void>;

    /**
     * @param moveToRecycleBin (optional) 
     * @return OK
     */
    filesDELETE(id: string, moveToRecycleBin?: boolean | undefined): Promise<void>;

    /**
     * @return OK
     */
    download(id: string): Promise<void>;

    /**
     * @param file (optional) 
     * @param destinationFolderId (optional) 
     * @return OK
     */
    upload(file?: FileParameter | undefined, destinationFolderId?: string | undefined): Promise<UploadFileResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    rename(id: string, body?: RenameFileRequest | undefined): Promise<RenameFileResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    tags(id: string, body?: AddTagsRequest | undefined): Promise<void>;

    /**
     * @param parentFolderId (optional) 
     * @return OK
     */
    foldersGET(parentFolderId?: string | undefined): Promise<GetFoldersResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    foldersPOST(body?: CreateFolderRequest | undefined): Promise<CreateFolderResult>;

    /**
     * @param body (optional) 
     * @return OK
     */
    rename2(id: string, body?: RenameFolderRequest | undefined): Promise<RenameFolderResult>;

    /**
     * @param deleteFiles (optional) 
     * @return OK
     */
    foldersDELETE(id: string, deleteFiles?: boolean | undefined): Promise<DeleteFolderResult>;
}

export class Client implements IClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param searchTerm (optional) 
     * @param tags (optional) 
     * @param isPhoto (optional) 
     * @param folderId (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @return OK
     */
    filesGET(searchTerm?: string | undefined, tags?: string[] | undefined, isPhoto?: boolean | undefined, folderId?: string | undefined, skip?: number | undefined, take?: number | undefined): Promise<SearchFilesResult> {
        let url_ = this.baseUrl + "/api/v1/Files?";
        if (searchTerm === null)
            throw new globalThis.Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (tags === null)
            throw new globalThis.Error("The parameter 'tags' cannot be null.");
        else if (tags !== undefined)
            tags && tags.forEach(item => { url_ += "tags=" + encodeURIComponent("" + item) + "&"; });
        if (isPhoto === null)
            throw new globalThis.Error("The parameter 'isPhoto' cannot be null.");
        else if (isPhoto !== undefined)
            url_ += "isPhoto=" + encodeURIComponent("" + isPhoto) + "&";
        if (folderId === null)
            throw new globalThis.Error("The parameter 'folderId' cannot be null.");
        else if (folderId !== undefined)
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (skip === null)
            throw new globalThis.Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new globalThis.Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFilesGET(_response);
        });
    }

    protected processFilesGET(response: Response): Promise<SearchFilesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SearchFilesResult;
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchFilesResult>(null as any);
    }

    /**
     * @return OK
     */
    filesGET2(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/Files/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFilesGET2(_response);
        });
    }

    protected processFilesGET2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param moveToRecycleBin (optional) 
     * @return OK
     */
    filesDELETE(id: string, moveToRecycleBin?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/Files/{id}?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (moveToRecycleBin === null)
            throw new globalThis.Error("The parameter 'moveToRecycleBin' cannot be null.");
        else if (moveToRecycleBin !== undefined)
            url_ += "moveToRecycleBin=" + encodeURIComponent("" + moveToRecycleBin) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFilesDELETE(_response);
        });
    }

    protected processFilesDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    download(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/Files/{id}/download";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param file (optional) 
     * @param destinationFolderId (optional) 
     * @return OK
     */
    upload(file?: FileParameter | undefined, destinationFolderId?: string | undefined): Promise<UploadFileResult> {
        let url_ = this.baseUrl + "/api/v1/Files/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new globalThis.Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        if (destinationFolderId === null || destinationFolderId === undefined)
            throw new globalThis.Error("The parameter 'destinationFolderId' cannot be null.");
        else
            content_.append("destinationFolderId", destinationFolderId.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<UploadFileResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UploadFileResult;
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UploadFileResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    rename(id: string, body?: RenameFileRequest | undefined): Promise<RenameFileResult> {
        let url_ = this.baseUrl + "/api/v1/Files/{id}/rename";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRename(_response);
        });
    }

    protected processRename(response: Response): Promise<RenameFileResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RenameFileResult;
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RenameFileResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tags(id: string, body?: AddTagsRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/Files/{id}/tags";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTags(_response);
        });
    }

    protected processTags(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param parentFolderId (optional) 
     * @return OK
     */
    foldersGET(parentFolderId?: string | undefined): Promise<GetFoldersResult> {
        let url_ = this.baseUrl + "/api/v1/Folders?";
        if (parentFolderId === null)
            throw new globalThis.Error("The parameter 'parentFolderId' cannot be null.");
        else if (parentFolderId !== undefined)
            url_ += "parentFolderId=" + encodeURIComponent("" + parentFolderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFoldersGET(_response);
        });
    }

    protected processFoldersGET(response: Response): Promise<GetFoldersResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetFoldersResult;
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetFoldersResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    foldersPOST(body?: CreateFolderRequest | undefined): Promise<CreateFolderResult> {
        let url_ = this.baseUrl + "/api/v1/Folders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFoldersPOST(_response);
        });
    }

    protected processFoldersPOST(response: Response): Promise<CreateFolderResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateFolderResult;
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateFolderResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    rename2(id: string, body?: RenameFolderRequest | undefined): Promise<RenameFolderResult> {
        let url_ = this.baseUrl + "/api/v1/Folders/{id}/rename";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRename2(_response);
        });
    }

    protected processRename2(response: Response): Promise<RenameFolderResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RenameFolderResult;
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RenameFolderResult>(null as any);
    }

    /**
     * @param deleteFiles (optional) 
     * @return OK
     */
    foldersDELETE(id: string, deleteFiles?: boolean | undefined): Promise<DeleteFolderResult> {
        let url_ = this.baseUrl + "/api/v1/Folders/{id}?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (deleteFiles === null)
            throw new globalThis.Error("The parameter 'deleteFiles' cannot be null.");
        else if (deleteFiles !== undefined)
            url_ += "deleteFiles=" + encodeURIComponent("" + deleteFiles) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFoldersDELETE(_response);
        });
    }

    protected processFoldersDELETE(response: Response): Promise<DeleteFolderResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeleteFolderResult;
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeleteFolderResult>(null as any);
    }
}

export interface AddTagsRequest {
    tags?: string[] | undefined;
}

export interface CreateFolderRequest {
    name?: string | undefined;
    parentFolderId?: string | undefined;
}

export interface CreateFolderResult {
    folderId?: string;
    folder?: FolderDto;
}

export interface DeleteFolderResult {
    success?: boolean;
    errorMessage?: string | undefined;
}

export interface FileItemDto {
    id?: string;
    path?: string | undefined;
    fileName?: string | undefined;
    hashHex?: string | undefined;
    size?: number;
    isCompressed?: boolean;
    mimeType?: string | undefined;
    tags?: string[] | undefined;
    createdDate?: string;
    isPhoto?: boolean;
    photoDateTaken?: string | undefined;
    cameraMake?: string | undefined;
    cameraModel?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
    thumbnailPath?: string | undefined;
    folderId?: string | undefined;
    folderPath?: string | undefined;
}

export interface FolderDto {
    id?: string;
    path?: string | undefined;
    name?: string | undefined;
    parentFolderId?: string | undefined;
    createdDate?: string;
    fileCount?: number;
    subFolderCount?: number;
}

export interface GetFoldersResult {
    folders?: FolderDto[] | undefined;
}

export interface ProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export interface RenameFileRequest {
    newName?: string | undefined;
}

export interface RenameFileResult {
    success?: boolean;
    newPath?: string | undefined;
}

export interface RenameFolderRequest {
    newName?: string | undefined;
}

export interface RenameFolderResult {
    success?: boolean;
    folder?: FolderDto;
    errorMessage?: string | undefined;
}

export interface SearchFilesResult {
    files?: FileItemDto[] | undefined;
    totalCount?: number;
}

export interface UploadFileResult {
    fileId?: string;
    isDuplicate?: boolean;
    filePath?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}